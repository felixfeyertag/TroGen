/*
 * Copyright (C) 2014 The University of Manchester
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2.0 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package org.mcr.trogen.filetype;

import java.util.Map;
import javafx.application.Platform;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.embed.swing.JFXPanel;
import javafx.geometry.Bounds;
import javafx.geometry.Insets;
import javafx.geometry.Pos;
import javafx.scene.Node;
import javafx.scene.Scene;
import javafx.scene.chart.AreaChart;
import javafx.scene.chart.PieChart;
import javafx.scene.chart.PieChart.Data;
import javafx.scene.control.CheckBoxTreeItem;
import javafx.scene.control.Label;
import javafx.scene.control.ScrollPane;
import javafx.scene.control.TitledPane;
import javafx.scene.control.TreeItem;
import javafx.scene.control.TreeView;
import javafx.scene.effect.DropShadow;
import javafx.scene.layout.BorderPane;
import javafx.scene.layout.GridPane;
import javafx.scene.layout.StackPane;
import javafx.scene.layout.VBox;
import javafx.scene.paint.Color;
import javafx.scene.text.Font;
import javafx.scene.text.FontWeight;
import javax.swing.Action;
import javax.swing.GroupLayout;
import javax.swing.JComponent;
import javax.swing.JPanel;
import javax.swing.JToolBar;
import org.netbeans.core.spi.multiview.CloseOperationState;
import org.netbeans.core.spi.multiview.MultiViewElement;
import org.netbeans.core.spi.multiview.MultiViewElementCallback;
import org.openide.awt.UndoRedo;
import org.openide.util.Lookup;
import org.openide.util.NbBundle.Messages;
import org.openide.windows.TopComponent;
import org.w3c.dom.NodeList;

@MultiViewElement.Registration(
        displayName = "#LBL_TroGenResults_VISUAL2",
        iconBase = "org/mcr/trogen/filetype/tg.png",
        mimeType = "text/trogen+xml",
        persistenceType = TopComponent.PERSISTENCE_NEVER,
        preferredID = "TroGenResultsVisual2",
        position = 3000)
@Messages({"LBL_TroGenResults_VISUAL2=Visual2"
})
public final class TroGenResultsVisualElement2 extends JPanel implements MultiViewElement {

    private TroGenResultsDataObject obj;
    private JToolBar toolbar = new JToolBar();
    private transient MultiViewElementCallback callback;
    private static JFXPanel fxContainer;

    public TroGenResultsVisualElement2(Lookup lkp) {
        obj = lkp.lookup(TroGenResultsDataObject.class);
        assert obj != null;
        fxContainer = new JFXPanel();

        GroupLayout layout = new GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(fxContainer, GroupLayout.DEFAULT_SIZE, 376, Short.MAX_VALUE)
                        .addContainerGap()));
        layout.setVerticalGroup(
                layout.createParallelGroup(GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(fxContainer, GroupLayout.DEFAULT_SIZE, 276, Short.MAX_VALUE)
                        .addContainerGap()));

        Platform.setImplicitExit(false);
        Platform.runLater(new Runnable() {
            @Override
            public void run() {
                createScene();
            }
        });
        //initComponents();
    }

    @Override
    public String getName() {
        return "TroGenResultsVisualElement";
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 388, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 288, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    @Override
    public JComponent getVisualRepresentation() {
        return this;
    }

    @Override
    public JComponent getToolbarRepresentation() {
        return toolbar;
    }

    @Override
    public Action[] getActions() {
        return new Action[0];
    }

    @Override
    public Lookup getLookup() {
        return obj.getLookup();
    }

    @Override
    public void componentOpened() {
    }

    @Override
    public void componentClosed() {
    }

    @Override
    public void componentShowing() {
    }

    @Override
    public void componentHidden() {
    }

    @Override
    public void componentActivated() {
    }

    @Override
    public void componentDeactivated() {
    }

    @Override
    public UndoRedo getUndoRedo() {
        return UndoRedo.NONE;
    }

    @Override
    public void setMultiViewCallback(MultiViewElementCallback callback) {
        this.callback = callback;
    }

    @Override
    public CloseOperationState canCloseElement() {
        return CloseOperationState.STATE_OK;
    }

    private void createScene() {

        /*GridPane sliderPane = new GridPane();
        final Label sliderLabel = new Label("False Positive Rate:");
        sliderLabel.setFont(Font.font(null, FontWeight.BOLD, 20));

        sliderPane.setPadding(new Insets(10, 10, 10, 10));
        sliderPane.setVgap(10);
        sliderPane.setHgap(70);
        sliderPane.add(sliderLabel, 0, 0);
        sliderPane.add(obj.getFprSlider(), 1, 0);
        sliderPane.add(obj.getFprValue(), 2, 0);

        DropShadow ds2 = new DropShadow();

        final String css2 = "-fx-background-color: white;\n"
                + "-fx-border-insets: 5;\n"
                + "-fx-border-width: 3;\n";

        sliderPane.setStyle(css2);
        sliderPane.setEffect(ds2);*/

        BorderPane resultsScreen = new BorderPane();
        //resultsScreen.setTop(sliderPane);
        resultsScreen.setCenter(createStackedTitledPanes());
        
        ScrollPane resultsScreenPane = new ScrollPane();
        resultsScreenPane.setContent(resultsScreen);

        fxContainer.setScene(new Scene(resultsScreenPane));

    }

    private VBox createStackedTitledPanes() {
        final VBox stackedTitledPanes = new VBox();
        
        final Map<String,PieChart> pieCharts = obj.getPieCharts();
        final Map<String,AreaChart> areaCharts = obj.getAreaCharts();
        //final Map<String,BorderPane> distributionCharts;
        
        for (String algorithm : pieCharts.keySet()) {
            int x4count = (int) pieCharts.get(algorithm).getData().get(0).getPieValue();
            int r5count = (int) pieCharts.get(algorithm).getData().get(1).getPieValue();
            BorderPane layout = new BorderPane();
            
            
            GridPane numericStatPane = new GridPane();
            
            final Label x4Label = new Label("CXCR4 Count");
            final Label x4Count = obj.getX4CountLabel().get(algorithm);
            
            final Label r5Label = new Label("CCR5 Count");
            final Label r5Count = obj.getR5CountLabel().get(algorithm);
            
            final Label totalLabel = new Label("Total Number of Sequences");
            final Label totalCount = obj.getTotalCountLabel().get(algorithm);
            
            numericStatPane.setPadding(new Insets(10, 10, 10, 10));
            numericStatPane.setVgap(10);
            numericStatPane.setHgap(10);
            
            numericStatPane.add(x4Label, 0, 0);
            numericStatPane.add(x4Count, 1, 0);
            numericStatPane.add(r5Label, 0, 1);
            numericStatPane.add(r5Count, 1, 1);
            numericStatPane.add(totalLabel, 0, 2);
            numericStatPane.add(totalCount, 1, 2);
            
            DropShadow ds = new DropShadow();
            ds.setOffsetX(3.0);
            ds.setOffsetY(3.0);
            ds.setColor(Color.GRAY);
            
            numericStatPane.setEffect(ds);
            
            layout.setLeft(numericStatPane);
            layout.setCenter(pieCharts.get(algorithm));
            layout.setRight(areaCharts.get(algorithm));
            
            stackedTitledPanes.getChildren().add(createTitledPane(algorithm, layout));
        }
        
        ((TitledPane) stackedTitledPanes.getChildren().get(0)).setExpanded(true);
        stackedTitledPanes.getStyleClass().add("summary-panes");

        return stackedTitledPanes;
    }

    public TitledPane createTitledPane(String title, Node... images) {
        VBox content = new VBox();
        for (Node image : images) {
            content.getChildren().add(image);
            //StackPane.setMargin(image, new Insets(10));
        }
        content.setAlignment(Pos.CENTER);
        TitledPane pane = new TitledPane(title, content);
        pane.getStyleClass().add("summary-pane");
        pane.setExpanded(true);

        return pane;
    }

    private ScrollPane makeScrollable(final VBox node) {
        final ScrollPane scroll = new ScrollPane();
        scroll.setContent(node);
        scroll.viewportBoundsProperty().addListener(new ChangeListener<Bounds>() {
            @Override
            public void changed(ObservableValue<? extends Bounds> ov, Bounds oldBounds, Bounds bounds) {
                node.setPrefWidth(bounds.getWidth());
                //node.setPrefHeight(bounds.getHeight());
            }
        });
        return scroll;
    }
}
